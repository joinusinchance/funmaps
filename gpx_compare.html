<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPX Comparison Tool</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://unpkg.com/gpxparser@3.0.7/dist/gpxparser.js"></script> 
    
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background-color: #f4f4f9; }
        .container { max-width: 1200px; margin: 0 auto; background-color: #fff; padding: 30px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        h1, h2 { color: #333; border-bottom: 2px solid #eee; padding-bottom: 10px; margin-bottom: 20px; }
        #fileInput { margin-bottom: 20px; padding: 10px; border: 1px solid #ccc; border-radius: 4px; display: block; width: 100%; box-sizing: border-box; }
        #chartContainer { width: 100%; height: 400px; margin-bottom: 30px; }
        #statsTable { width: 100%; border-collapse: collapse; margin-top: 20px; }
        #statsTable th, #statsTable td { border: 1px solid #ddd; padding: 12px; text-align: left; }
        #statsTable th { background-color: #007bff; color: white; }
        #statsTable tr:nth-child(even) { background-color: #f2f2f2; }
        .error-message { color: #d9534f; padding: 10px; border: 1px solid #d9534f; background-color: #fdd; margin-bottom: 15px; border-radius: 4px; }
        .loading-message { text-align: center; font-style: italic; color: #555; }
    </style>
</head>
<body>

    <div class="container">
        <h1>üó∫Ô∏è GPX Elevation Comparison</h1>

        <input type="file" id="fileInput" multiple accept=".gpx">
        <div id="statusMessage" class="loading-message" style="display:none;">Parsing files...</div>

        <h2>Elevation Profile (Time vs. Elevation)</h2>
        <div id="chartContainer">
            <canvas id="elevationChart"></canvas>
        </div>

        <h2>Summary Statistics</h2>
        <table id="statsTable">
            <thead>
                <tr>
                    <th>File Name</th>
                    <th>Total Distance (km)</th>
                    <th>Elevation Gain (m)</th>
                    <th>Duration (hrs:min)</th>
                </tr>
            </thead>
            <tbody>
                <tr><td colspan="4">Select one or more GPX files (.gpx) to compare.</td></tr>
            </tbody>
        </table>
    </div>

    <script>
        const fileInput = document.getElementById('fileInput');
        const statsTableBody = document.querySelector('#statsTable tbody');
        const chartCanvas = document.getElementById('elevationChart');
        const statusMessage = document.getElementById('statusMessage');
        let elevationChart;

        /**
         * Parses the GPX file content using GPXParser.js and extracts required data.
         * @param {string} fileName - The name of the file.
         * @param {string} gpxContent - The XML content of the GPX file.
         * @returns {object} Parsed GPX data including stats and chart data.
         */
        function parseGpx(fileName, gpxContent) {
            const gpx = new gpxParser();
            try {
                gpx.parse(gpxContent);
            } catch (e) {
                console.error(`Error parsing ${fileName}:`, e);
                throw new Error(`Invalid GPX format in ${fileName}`);
            }

            // GPXParser.js computes statistics on the first track by default
            const track = gpx.tracks[0];
            if (!track || !track.points || track.points.length < 2) {
                throw new Error(`No valid track data found in ${fileName}.`);
            }

            // 1. Total Distance (meters to km)
            const distanceKm = (gpx.distance.total / 1000).toFixed(2);
            
            // 2. Elevation Gain (using positive elevation from stats)
            // Note: track.elevation.pos is often calculated based on smoothing and is more accurate than raw point-to-point sums.
            const elevationGainMeters = Math.floor(gpx.elevation.pos); 

            // 3. Duration (calculated from first and last point timestamps)
            const startTime = track.points[0].time;
            const endTime = track.points[track.points.length - 1].time;
            const durationMs = new Date(endTime).getTime() - new Date(startTime).getTime();
            const durationHoursTotal = durationMs / (1000 * 60 * 60);

            const hours = Math.floor(durationHoursTotal);
            const minutes = Math.floor((durationHoursTotal - hours) * 60);
            const formattedDuration = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;

            // 4. Chart Data: Elevation vs. Time (in hours)
            const chartData = track.points.map((point) => {
                const pointTimeMs = new Date(point.time).getTime();
                // Time offset from the start of the track, converted to hours
                const timeOffsetHours = (pointTimeMs - new Date(startTime).getTime()) / (1000 * 60 * 60);

                return {
                    x: timeOffsetHours, // Time in hours from start
                    y: point.ele // Elevation in meters
                };
            });

            return {
                name: fileName,
                distance: distanceKm,
                elevationGain: elevationGainMeters,
                duration: formattedDuration,
                chartData: chartData,
            };
        }

        // --- Charting and Table Logic (Unchanged from previous solution) ---

        /**
         * Initializes or updates the Chart.js graph.
         * @param {Array} gpxDataArray - Array of parsed GPX data objects.
         */
        function updateChart(gpxDataArray) {
            const colors = [
                'rgba(0, 123, 255, 1)',  // Blue
                'rgba(40, 167, 69, 1)',  // Green
                'rgba(255, 193, 7, 1)',  // Yellow
                'rgba(220, 53, 69, 1)',  // Red
                'rgba(111, 66, 193, 1)', // Purple
                'rgba(23, 162, 184, 1)'  // Cyan
            ];

            const datasets = gpxDataArray.map((gpx, index) => ({
                label: gpx.name,
                data: gpx.chartData,
                borderColor: colors[index % colors.length],
                borderWidth: 2,
                fill: false,
                tension: 0.1,
                pointRadius: 0,
                parsing: {
                    xAxisKey: 'x', // Time in hours
                    yAxisKey: 'y'  // Elevation in meters
                }
            }));

            const data = { datasets };

            const config = {
                type: 'line',
                data: data,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Time (Hours from Start)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Elevation (Meters)'
                            },
                            beginAtZero: true
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                        },
                        tooltip: {
                            callbacks: {
                                title: (context) => `Time: ${context[0].parsed.x.toFixed(2)} hrs`,
                                label: (context) => `${context.dataset.label}: ${context.parsed.y} m`
                            }
                        }
                    }
                }
            };

            if (elevationChart) {
                elevationChart.destroy();
            }

            elevationChart = new Chart(chartCanvas, config);
        }

        /**
         * Populates the summary statistics table.
         * @param {Array} gpxDataArray - Array of parsed GPX data objects.
         */
        function updateStatsTable(gpxDataArray) {
            statsTableBody.innerHTML = '';
            if (gpxDataArray.length === 0) {
                 statsTableBody.innerHTML = '<tr><td colspan="4">No data to display.</td></tr>';
                 return;
            }
            gpxDataArray.forEach(gpx => {
                const row = statsTableBody.insertRow();
                row.insertCell().textContent = gpx.name;
                row.insertCell().textContent = gpx.distance;
                row.insertCell().textContent = gpx.elevationGain;
                row.insertCell().textContent = gpx.duration;
            });
        }

        /**
         * Main handler for file selection and parsing.
         * Uses FileReader to asynchronously read each file.
         */
        function handleFiles(event) {
            const files = event.target.files;
            if (files.length === 0) {
                statsTableBody.innerHTML = '<tr><td colspan="4">Select one or more GPX files (.gpx) to compare.</td></tr>';
                if (elevationChart) elevationChart.destroy();
                return;
            }
            
            statusMessage.style.display = 'block';
            statsTableBody.innerHTML = '';
            
            const parsedGpxData = [];
            let filesProcessed = 0;

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const reader = new FileReader();

                reader.onload = (e) => {
                    try {
                        const gpxContent = e.target.result;
                        // Use the real GPXParser logic
                        const data = parseGpx(file.name, gpxContent); 
                        parsedGpxData.push(data);
                    } catch (error) {
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'error-message';
                        errorDiv.textContent = `Error processing ${file.name}: ${error.message}`;
                        document.querySelector('.container').insertBefore(errorDiv, statusMessage);
                    } finally {
                        filesProcessed++;
                        // Check if all files are processed
                        if (filesProcessed === files.length) {
                            statusMessage.style.display = 'none';
                            updateChart(parsedGpxData);
                            updateStatsTable(parsedGpxData);
                        }
                    }
                };

                reader.onerror = () => {
                    alert(`Failed to read file: ${file.name}`);
                    filesProcessed++;
                    if (filesProcessed === files.length) {
                         statusMessage.style.display = 'none';
                         updateChart(parsedGpxData);
                         updateStatsTable(parsedGpxData);
                    }
                };

                reader.readAsText(file);
            }
        }

        fileInput.addEventListener('change', handleFiles);
    </script>
</body>
</html>
