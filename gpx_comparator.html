<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPX Route Analyzer & Plotter</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 1200px; margin: auto; }
        #fileInput { margin-bottom: 20px; padding: 10px; border: 1px solid #ccc; border-radius: 5px; }
        #statsTable { width: 100%; border-collapse: collapse; margin-top: 20px; }
        #statsTable th, #statsTable td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        #statsTable th { background-color: #f2f2f2; }
        #chartContainer { margin-top: 40px; border: 1px solid #ddd; padding: 15px; border-radius: 5px; }
    </style>
</head>
<body>

    <div class="container">
        <h1>GPX Route Analyzer</h1>
        
        <input type="file" id="fileInput" accept=".gpx" multiple onchange="handleFiles(event)">
        <p>Select two or more GPX files to plot and compare their elevation profiles.</p>

        <div id="loadingMessage" style="display:none; color: blue;">Processing files...</div>

        <h2>Route Statistics</h2>
        <table id="statsTable">
            <thead>
                <tr>
                    <th>Name</th>
                    <th>Total Distance (km)</th>
                    <th>Total Vertical Gain (m)</th>
                </tr>
            </thead>
            <tbody>
                </tbody>
        </table>

        <div id="chartContainer">
            <h2>Elevation Profile</h2>
            <canvas id="elevationChart"></canvas>
        </div>
    </div>

    <script>
        // --- Core GPX Analysis Logic (JS Version of Python Code) ---
        
        const R = 6371000.0; // Earth's radius in meters
        let gpxChart = null; // Variable to hold the Chart.js instance

        /**
         * Calculates the 2D distance between two points using the Haversine formula.
         */
        function haversine(lat1, lon1, lat2, lon2) {
            const toRad = (degrees) => degrees * (Math.PI / 180);

            const rLat1 = toRad(lat1);
            const rLon1 = toRad(lon1);
            const rLat2 = toRad(lat2);
            const rLon2 = toRad(lon2);

            const dLon = rLon2 - rLon1;
            const dLat = rLat2 - rLat1;

            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(rLat1) * Math.cos(rLat2) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c; // Distance in meters
        }

        /**
         * Parses GPX content (XML string) and calculates distance/elevation data.
         * Returns an object with stats and plot data (x: distance, y: elevation).
         */
        function analyzeGpx(gpxContent, fileName) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(gpxContent, "text/xml");
            
            // Try to find the track name in the common places (gpx:trk/gpx:name, etc.)
            const nameElements = xmlDoc.getElementsByTagName('name');
            let trackName = fileName;
            for (let i = 0; i < nameElements.length; i++) {
                if (nameElements[i].parentNode.tagName.toLowerCase() === 'trk') {
                    trackName = nameElements[i].textContent;
                    break;
                }
            }

            const points = [];
            const trkpts = xmlDoc.getElementsByTagName('trkpt');
            
            for (let i = 0; i < trkpts.length; i++) {
                const trkpt = trkpts[i];
                const lat = parseFloat(trkpt.getAttribute('lat'));
                const lon = parseFloat(trkpt.getAttribute('lon'));
                const eleElement = trkpt.getElementsByTagName('ele')[0];
                const ele = eleElement ? parseFloat(eleElement.textContent) : NaN;
                
                if (!isNaN(lat) && !isNaN(lon)) {
                    points.push({ lat, lon, ele });
                }
            }
            
            if (points.length === 0) {
                throw new Error(`No valid points found in ${fileName}`);
            }

            // Simple elevation interpolation (Forward-fill, then Backward-fill)
            let lastValidEle = points[0].ele;
            for (const p of points) {
                if (!isNaN(p.ele)) lastValidEle = p.ele;
                else if (!isNaN(lastValidEle)) p.ele = lastValidEle;
            }
            let firstValidEle = points[points.length - 1].ele;
            for (let i = points.length - 1; i >= 0; i--) {
                const p = points[i];
                if (!isNaN(p.ele)) firstValidEle = p.ele;
                else if (!isNaN(firstValidEle)) p.ele = firstValidEle;
            }
            // Final fallback to 0 if all elevations are missing
            if (isNaN(points[0].ele)) points.forEach(p => p.ele = 0);

            // Calculation loop
            const plotData = [];
            let totalVerticalGain = 0.0;
            let cumulativeDistance = 0.0;
            
            plotData.push({ x: 0.0, y: points[0].ele }); // Start point

            for (let i = 1; i < points.length; i++) {
                const p1 = points[i - 1];
                const p2 = points[i];

                const distance2D = haversine(p1.lat, p1.lon, p2.lat, p2.lon);
                const elevationDiff = p2.ele - p1.ele;
                const distance3D = Math.sqrt(distance2D * distance2D + elevationDiff * elevationDiff);

                cumulativeDistance += distance3D;

                if (elevationDiff > 0) {
                    totalVerticalGain += elevationDiff;
                }
                
                plotData.push({ 
                    x: cumulativeDistance / 1000, // Distance in km
                    y: p2.ele                   // Elevation in meters
                });
            }

            const stats = {
                'Name': trackName,
                'Total Distance (km)': cumulativeDistance / 1000,
                'Total Vertical Gain (m)': totalVerticalGain,
            };

            return { stats, plotData, fileName };
        }

        // --- UI and Charting Functions ---

        /**
         * Cleans up the previous chart and renders a new one using Chart.js.
         */
        function renderChart(results) {
            if (gpxChart) {
                gpxChart.destroy();
            }

            const ctx = document.getElementById('elevationChart').getContext('2d');
            const colors = ['#007bff', '#dc3545', '#ffc107', '#28a745', '#6f42c1', '#17a2b8']; // Chart colors

            const datasets = results.map((result, index) => {
                const color = colors[index % colors.length];
                return {
                    label: result.stats.Name,
                    data: result.plotData,
                    borderColor: color,
                    backgroundColor: 'rgba(0, 0, 0, 0)', // Transparent fill
                    borderWidth: 2,
                    pointRadius: 0, // Hide points for a smoother line
                    tension: 0.1, // Slight curve
                    parsing: false, // Use pre-processed x/y values
                    showLine: true
                };
            });

            gpxChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'Distance (km)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Elevation (m)'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.dataset.label || '';
                                    if (label) {
                                        let point = context.raw;
                                        return `${label}: ${point.y.toFixed(2)}m @ ${point.x.toFixed(2)}km`;
                                    }
                                    return '';
                                }
                            }
                        }
                    }
                }
            });
            // Adjust canvas height after chart creation for better appearance
            document.getElementById('elevationChart').style.height = '400px'; 
        }

        /**
         * Updates the HTML table with calculated statistics.
         */
        function updateStatsTable(results) {
            const tbody = document.querySelector('#statsTable tbody');
            tbody.innerHTML = ''; // Clear previous results

            for (const result of results) {
                const stats = result.stats;
                const row = tbody.insertRow();
                
                row.insertCell().textContent = stats.Name;
                row.insertCell().textContent = stats['Total Distance (km)'].toFixed(2);
                row.insertCell().textContent = stats['Total Vertical Gain (m)'].toFixed(2);
            }
        }

        /**
         * Main function to handle file selection and processing.
         */
        function handleFiles(event) {
            const files = event.target.files;
            const loadingMessage = document.getElementById('loadingMessage');
            
            if (files.length === 0) return;

            loadingMessage.style.display = 'block';
            let gpxResults = [];
            let filesProcessed = 0;
            
            // Use Promise to manage asynchronous file reading
            const processFile = (file) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const result = analyzeGpx(e.target.result, file.name);
                            resolve(result);
                        } catch (error) {
                            reject(`Error processing ${file.name}: ${error.message}`);
                        }
                    };
                    reader.onerror = () => reject(`Failed to read file: ${file.name}`);
                    reader.readAsText(file);
                });
            };

            // Process all files concurrently
            const processingPromises = Array.from(files).map(processFile);

            Promise.allSettled(processingPromises)
                .then(results => {
                    loadingMessage.style.display = 'none';
                    gpxResults = results
                        .filter(res => res.status === 'fulfilled')
                        .map(res => res.value);

                    if (gpxResults.length > 0) {
                        updateStatsTable(gpxResults);
                        renderChart(gpxResults);
                    } else {
                        alert("No valid GPX files were processed.");
                        updateStatsTable([]); // Clear table
                        if (gpxChart) gpxChart.destroy(); // Clear chart
                    }

                    results.forEach(res => {
                        if (res.status === 'rejected') {
                            console.error(res.reason);
                            // Optionally alert the user about specific file errors
                        }
                    });
                });
        }
    </script>
</body>
</html>
